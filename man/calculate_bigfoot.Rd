% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_pixel_footstats.R
\name{calculate_bigfoot}
\alias{calculate_bigfoot}
\alias{calculate_bigfoot.sf}
\alias{calculate_bigfoot.sp}
\alias{calculate_bigfoot.character}
\title{calculate_bigfoot: Gridded feature statistics for large sets of
  building footprint polygons}
\usage{
calculate_bigfoot(
  X,
  what = "all",
  how = "all",
  focalRadius = 0,
  controlZone = list(zoneName = "zoneID", method = "centroid"),
  controlUnits = list(areaUnit = "m^2", perimUnit = "m", distUnit = "m"),
  controlDist = list(maxSearch = 100, method = "centroid", unit =
    controlUnits$distUnit),
  filter = list(minArea = NULL, maxArea = NULL),
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = getwd(),
  outputTag = NULL,
  tries = 100,
  verbose = TRUE
)

\method{calculate_bigfoot}{sf}(
  X,
  what = "all",
  how = "all",
  focalRadius = 0,
  controlZone = list(zoneName = "zoneID", method = "centroid"),
  controlUnits = list(areaUnit = "m^2", perimUnit = "m", distUnit = "m"),
  controlDist = list(maxSearch = 100, method = "centroid", unit =
    controlUnits$distUnit),
  filter = list(minArea = NULL, maxArea = NULL),
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = getwd(),
  outputTag = NULL,
  tries = 100,
  verbose = TRUE
)

\method{calculate_bigfoot}{sp}(
  X,
  what = "all",
  how = "all",
  focalRadius = 0,
  controlZone = list(zoneName = "zoneID", method = "centroid"),
  controlUnits = list(areaUnit = "m^2", perimUnit = "m", distUnit = "m"),
  controlDist = list(maxSearch = 100, method = "centroid", unit =
    controlUnits$distUnit),
  filter = list(minArea = NULL, maxArea = NULL),
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = getwd(),
  outputTag = NULL,
  tries = 100,
  verbose = TRUE
)

\method{calculate_bigfoot}{character}(
  X,
  what = "all",
  how = "all",
  focalRadius = 0,
  controlZone = list(zoneName = "zoneID", method = "centroid"),
  controlUnits = list(areaUnit = "m^2", perimUnit = "m", distUnit = "m"),
  controlDist = list(maxSearch = 100, method = "centroid", unit =
    controlUnits$distUnit),
  filter = list(minArea = NULL, maxArea = NULL),
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = getwd(),
  outputTag = NULL,
  tries = 100,
  verbose = TRUE
)
}
\arguments{
\item{X}{object with building footprint polygons. This argument can take
multiple spatial types, including \code{sf} and \code{sp}, or a filepath
string to a file, or a list where each member provides a spatial object or
a filepath string.}

\item{what}{list of strings naming the columns or built-in geometry measures to
calculate for each footprint. Other options include \code{'all'} or
\code{'nodist'} to calculate all available characteristics and all except
nearest-neighbour distance metrics.}

\item{how}{list of strings naming functions to be used to calculate summary
statistics. The functions can be built-in functions (e.g. "mean","sd"), or
user-defined function names.}

\item{focalRadius}{numeric. Distance in meters for a buffer around each
template pixel. Creates a focal processing window for metrics.}

\item{controlZone}{(optional) named list. Setting controls passed on to 
\code{\link[foot]{zonalIndex}}. Elements can include \code{zoneName} and
\code{method}.}

\item{controlUnits}{(optional) named list. Elements can include
\code{areaUnit}, \code{perimUnit}, and \code{distUnit}. The values for
these items should be strings that can be coerced into a \code{units}
object.}

\item{controlDist}{(optional) named list to override default
options for distance calculations. Elements can include \code{maxSearch}
and \code{method}. Ignored if \code{metrics} does not include a distance
calculation. See \code{\link[foot]{fs_nndist}}.}

\item{filter}{(optional) named list with \code{minArea} and \code{maxArea}.
These are numeric values to filter footprints prior to processing. Default
values are \code{NULL} and do not filter any records.}

\item{template}{(optional). When creating a gridded output, a supplied
\code{stars} or \code{raster} dataset to align the data.}

\item{tileSize}{number of pixels per side of a tile. Can be a vector of
length 2 (rows, column pixels). Ignored if n provided. Default is 1000.}

\item{parallel}{logical. Should a parallel backend be used to process the
tiles.}

\item{nCores}{number of CPU cores to use if \code{parallel} is \code{TRUE}.
Default is 1 less than the available CPUs.}

\item{outputPath}{(optional). When creating a gridded output, a path for the
location of the output. Default is the temp directory.}

\item{outputTag}{(optional). A character string that will be added to the
beginning of the output name for the gridded files.}

\item{tries}{(optional). The number of attempts to write a tile to the output
file. Default is 100.}

\item{verbose}{logical. Should progress messages be printed. Default
\code{TRUE}.}
}
\value{
Invisible. Returns a vector of paths to the output files.
}
\description{
Calculate selected metrics of building footprints for
  high-spatial resolution gridded outputs.
}
\details{
calculate_bigfoot

\code{calculate_bigfoot} provides a wrapper for a workflow to
  process vector polygons of structures to create a gridded output summary of
  morphology measures. The function wraps \code{calculate_footstats} along
  with other geometry functions of \code{foot} and read/writing functions
  from \code{stars} and \code{sf}.
  
  The suggested way of using this function is to supply character strings for
  \code{X} and \code{template} rather than objects. Using strings is more
  memory-efficient. This function processes based on 'tiles' or sub-regions
  of the template grid and will only read in the portion of the object needed
  for the calculations.
}
\examples{
data("kampala", package="foot")
buildings <- kampala$buildings
templateGrid <- kampala$mastergrid

calculate_bigfoot(X=buildings,
                  what=list(list("shape"), list("perimeter")),
                  how=list(list("mean"), list("sum")),
                  controlUnits=list(areaUnit="m^2"),
                  minArea=50,  # footprints must be larger than 50 m^2
                  maxArea=1000,  # footprints must be smaller than 1000 m^2
                  template=templateGrid, 
                  outputPath=tempdir(),  
                  outputTag="kampala",
                  parallel=FALSE,
                  verbose=TRUE)  

# read one of the output files and plot as a raster layer
outGrid <- raster::raster(file.path(tempdir(), "kampala_count.tif"))
raster::plot(outGrid)

}
